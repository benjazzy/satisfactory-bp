mod recipe_list;
mod resource_list;

use std::io::Write;

pub use recipe_list::*;
pub use resource_list::*;

use winnow::{
    Bytes, Parser,
    binary::{le_u32, le_u64},
    combinator::{alt, fail, seq},
    error::StrContext,
};

use crate::bp_write::BPWrite;

const MAGIC_NUM: u32 = 0x9E2A83C1;
const MAX_CHUNK_SIZE: u32 = 128 * 1024;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum BodyHeaderVersion {
    V1,

    #[default]
    V2,
}

impl BodyHeaderVersion {
    const V1BYTES: &[u8] = &[0x00; 4];
    const V2BYTES: &[u8] = &[0x22; 4];
}

impl<W: Write> BPWrite<W> for BodyHeaderVersion {
    fn bp_write(self, writer: &mut W) -> Result<(), std::io::Error> {
        match self {
            Self::V1 => Self::V1BYTES.bp_write(writer),
            Self::V2 => Self::V2BYTES.bp_write(writer),
        }
    }
}

pub fn body_header_version(data: &mut &Bytes) -> winnow::Result<BodyHeaderVersion> {
    alt((
        BodyHeaderVersion::V1BYTES
            .map(|_| BodyHeaderVersion::V1)
            .context(StrContext::Label("Version 1")),
        BodyHeaderVersion::V2BYTES
            .map(|_| BodyHeaderVersion::V2)
            .context(StrContext::Label("Version 2")),
        fail.context(StrContext::Label("Did not match V1 or V2")),
    ))
    .parse_next(data)
}

// Header does not write the compressed and uncompressed size of the body
#[derive(Debug, Clone, PartialEq, Eq, Default)]
pub struct Header<'d> {
    pub maybe_header_version: u32,
    pub maybe_save_version: u32,
    pub maybe_build_version: u32,
    pub blueprint_size: [u32; 3],
    pub resource_list: ResourceList<'d>,
    pub recipie_list: RecipeList<'d>,
    pub header_version: BodyHeaderVersion,
    // pub body_header: BodyHeader,
}

impl Header<'_> {}

impl<W: Write> BPWrite<W> for &Header<'_> {
    fn bp_write(self, writer: &mut W) -> Result<(), std::io::Error> {
        self.maybe_header_version.bp_write(writer)?;
        self.maybe_save_version.bp_write(writer)?;
        self.maybe_build_version.bp_write(writer)?;
        for size in self.blueprint_size {
            size.bp_write(writer)?;
        }
        self.resource_list.bp_write(writer)?;
        self.recipie_list.bp_write(writer)?;

        MAGIC_NUM.bp_write(writer)?;
        self.header_version.bp_write(writer)?;
        MAX_CHUNK_SIZE.bp_write(writer)?;
        [0u8].bp_write(writer)?;
        0x03000000u32.bp_write(writer)
        // self.body_header.bp_write(writer)
    }
}

pub fn header<'d>(data: &mut &'d Bytes) -> winnow::Result<Header<'d>> {
    const MAGIC_NUMBER_BYTES: &[u8] = MAGIC_NUM.to_le_bytes().as_slice();
    const MAX_CHUNK_SIZE_BYTES: &[u8] = MAX_CHUNK_SIZE.to_le_bytes().as_slice();
    const PADDING: &[u8] = &[0x00, 0x00, 0x00, 0x00, 0x03];

    seq! {Header {
        maybe_header_version:le_u32.context(StrContext::Label("header version")),
        maybe_save_version: le_u32.context(StrContext::Label("save version")),
        maybe_build_version: le_u32.context(StrContext::Label("build version")),

        blueprint_size: (le_u32, le_u32, le_u32).map(Into::into)
            .context(StrContext::Label("blueprint size")),

        resource_list: resource_list
            .context(StrContext::Label("resource list")),
        recipie_list: recipe_list
            .context(StrContext::Label("recipie list")),

        _: MAGIC_NUMBER_BYTES.context(StrContext::Label("magic number 0x9E2A83C1")),
        header_version: body_header_version.context(StrContext::Label("header version")),
        _: MAX_CHUNK_SIZE_BYTES.context(StrContext::Label("maximum chunk size 131,072 ")),
        _: PADDING.context(StrContext::Label("padding")),
        _: le_u64.context(StrContext::Label("first compressed size")),
        _: le_u64.context(StrContext::Label("first uncompressed size")),
        _: le_u64.context(StrContext::Label("second compressed size")),
        _: le_u64.context(StrContext::Label("second uncompressed size")),
        // body_header: body_header.context(StrContext::Label("body header")),
    }}
    .parse_next(data)
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn check_header() {
        const DATA: [u8; 0x208] = [
            0x02, 0x00, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 0xF3, 0xA0, 0x05, 0x00, 0x05, 0x00,
            0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x4E, 0x00, 0x00, 0x00, 0x2F, 0x47, 0x61, 0x6D, 0x65, 0x2F,
            0x46, 0x61, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x52, 0x65,
            0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x2F, 0x50, 0x61, 0x72, 0x74, 0x73, 0x2F, 0x53,
            0x74, 0x65, 0x65, 0x6C, 0x50, 0x6C, 0x61, 0x74, 0x65, 0x2F, 0x44, 0x65, 0x73, 0x63,
            0x5F, 0x53, 0x74, 0x65, 0x65, 0x6C, 0x50, 0x6C, 0x61, 0x74, 0x65, 0x2E, 0x44, 0x65,
            0x73, 0x63, 0x5F, 0x53, 0x74, 0x65, 0x65, 0x6C, 0x50, 0x6C, 0x61, 0x74, 0x65, 0x5F,
            0x43, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0x00,
            0x2F, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x46, 0x61, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x47,
            0x61, 0x6D, 0x65, 0x2F, 0x52, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x2F, 0x50,
            0x61, 0x72, 0x74, 0x73, 0x2F, 0x49, 0x72, 0x6F, 0x6E, 0x50, 0x6C, 0x61, 0x74, 0x65,
            0x2F, 0x44, 0x65, 0x73, 0x63, 0x5F, 0x49, 0x72, 0x6F, 0x6E, 0x50, 0x6C, 0x61, 0x74,
            0x65, 0x2E, 0x44, 0x65, 0x73, 0x63, 0x5F, 0x49, 0x72, 0x6F, 0x6E, 0x50, 0x6C, 0x61,
            0x74, 0x65, 0x5F, 0x43, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42,
            0x00, 0x00, 0x00, 0x2F, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x46, 0x61, 0x63, 0x74, 0x6F,
            0x72, 0x79, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x52, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63,
            0x65, 0x2F, 0x50, 0x61, 0x72, 0x74, 0x73, 0x2F, 0x43, 0x65, 0x6D, 0x65, 0x6E, 0x74,
            0x2F, 0x44, 0x65, 0x73, 0x63, 0x5F, 0x43, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x44,
            0x65, 0x73, 0x63, 0x5F, 0x43, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x5F, 0x43, 0x00, 0x02,
            0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00,
            0x00, 0x2F, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x46, 0x61, 0x63, 0x74, 0x6F, 0x72, 0x79,
            0x47, 0x61, 0x6D, 0x65, 0x2F, 0x50, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65,
            0x2F, 0x42, 0x75, 0x69, 0x6C, 0x64, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x42, 0x65, 0x61,
            0x6D, 0x73, 0x2F, 0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x5F, 0x42, 0x65, 0x61, 0x6D,
            0x5F, 0x50, 0x61, 0x69, 0x6E, 0x74, 0x65, 0x64, 0x2E, 0x52, 0x65, 0x63, 0x69, 0x70,
            0x65, 0x5F, 0x42, 0x65, 0x61, 0x6D, 0x5F, 0x50, 0x61, 0x69, 0x6E, 0x74, 0x65, 0x64,
            0x5F, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x00, 0x2F, 0x47, 0x61,
            0x6D, 0x65, 0x2F, 0x46, 0x61, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x47, 0x61, 0x6D, 0x65,
            0x2F, 0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x73, 0x2F, 0x42, 0x75, 0x69, 0x6C, 0x64,
            0x69, 0x6E, 0x67, 0x73, 0x2F, 0x57, 0x61, 0x6C, 0x6C, 0x73, 0x2F, 0x52, 0x65, 0x63,
            0x69, 0x70, 0x65, 0x5F, 0x57, 0x61, 0x6C, 0x6C, 0x5F, 0x38, 0x78, 0x34, 0x5F, 0x30,
            0x31, 0x2E, 0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x5F, 0x57, 0x61, 0x6C, 0x6C, 0x5F,
            0x38, 0x78, 0x34, 0x5F, 0x30, 0x31, 0x5F, 0x43, 0x00, 0xC1, 0x83, 0x2A, 0x9E, 0x22,
            0x22, 0x22, 0x22, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x4D, 0x02,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x4D, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x0A, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00,
        ];

        let header = header
            .parse((&DATA[..]).into())
            .expect("Parser should succeed");

        assert_eq!(header.maybe_header_version, 2);
        assert_eq!(header.maybe_save_version, 46);
        assert_eq!(header.maybe_build_version, 368883);
        assert_eq!(header.blueprint_size, [5, 5, 5]);
        assert_eq!(header.resource_list.resources.len(), 3);
        assert_eq!(header.recipie_list.recipies.len(), 2);

        let mut buf = Vec::new();
        header.bp_write(&mut buf).expect("Write should succeed");

        // Header does not write the compressed and uncompressed size of the body
        assert_eq!(buf, DATA[..DATA.len() - 32]);
    }
}
