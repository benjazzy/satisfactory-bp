mod recipe_list;
mod resource_list;

pub use recipe_list::*;
pub use resource_list::*;
use winnow::{Bytes, Parser, binary::le_u32, error::StrContext};

#[derive(Debug)]
struct Header<'d> {
    pub maybe_header_version: u32,
    pub maybe_save_version: u32,
    pub maybe_build_version: u32,
    pub blueprint_size: [u32; 3],
    pub resource_list: ResourceList<'d>,
    pub recipie_list: RecipeList<'d>,
}

pub fn header<'d>(data: &mut &'d Bytes) -> winnow::Result<Header<'d>> {
    let (maybe_header_version, maybe_save_version, maybe_build_version) = (
        le_u32.context(StrContext::Label("header version")),
        le_u32.context(StrContext::Label("save version")),
        le_u32.context(StrContext::Label("build version")),
    )
        .parse_next(data)?;
    let blueprint_size: [u32; 3] = (le_u32, le_u32, le_u32)
        .context(StrContext::Label("blueprint size"))
        .parse_next(data)?
        .into();
    let resource_list = resource_list
        .context(StrContext::Label("resource list"))
        .parse_next(data)?;
    let recipie_list = recipe_list
        .context(StrContext::Label("recipie list"))
        .parse_next(data)?;

    Ok(Header {
        maybe_header_version,
        maybe_save_version,
        maybe_build_version,
        blueprint_size,
        resource_list,
        recipie_list,
    })
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn check_header() {
        const DATA: [u8; 0x1D7] = [
            0x02, 0x00, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 0xF3, 0xA0, 0x05, 0x00, 0x05, 0x00,
            0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x4E, 0x00, 0x00, 0x00, 0x2F, 0x47, 0x61, 0x6D, 0x65, 0x2F,
            0x46, 0x61, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x52, 0x65,
            0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x2F, 0x50, 0x61, 0x72, 0x74, 0x73, 0x2F, 0x53,
            0x74, 0x65, 0x65, 0x6C, 0x50, 0x6C, 0x61, 0x74, 0x65, 0x2F, 0x44, 0x65, 0x73, 0x63,
            0x5F, 0x53, 0x74, 0x65, 0x65, 0x6C, 0x50, 0x6C, 0x61, 0x74, 0x65, 0x2E, 0x44, 0x65,
            0x73, 0x63, 0x5F, 0x53, 0x74, 0x65, 0x65, 0x6C, 0x50, 0x6C, 0x61, 0x74, 0x65, 0x5F,
            0x43, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0x00,
            0x2F, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x46, 0x61, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x47,
            0x61, 0x6D, 0x65, 0x2F, 0x52, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x2F, 0x50,
            0x61, 0x72, 0x74, 0x73, 0x2F, 0x49, 0x72, 0x6F, 0x6E, 0x50, 0x6C, 0x61, 0x74, 0x65,
            0x2F, 0x44, 0x65, 0x73, 0x63, 0x5F, 0x49, 0x72, 0x6F, 0x6E, 0x50, 0x6C, 0x61, 0x74,
            0x65, 0x2E, 0x44, 0x65, 0x73, 0x63, 0x5F, 0x49, 0x72, 0x6F, 0x6E, 0x50, 0x6C, 0x61,
            0x74, 0x65, 0x5F, 0x43, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42,
            0x00, 0x00, 0x00, 0x2F, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x46, 0x61, 0x63, 0x74, 0x6F,
            0x72, 0x79, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x52, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63,
            0x65, 0x2F, 0x50, 0x61, 0x72, 0x74, 0x73, 0x2F, 0x43, 0x65, 0x6D, 0x65, 0x6E, 0x74,
            0x2F, 0x44, 0x65, 0x73, 0x63, 0x5F, 0x43, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x44,
            0x65, 0x73, 0x63, 0x5F, 0x43, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x5F, 0x43, 0x00, 0x02,
            0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00,
            0x00, 0x2F, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x46, 0x61, 0x63, 0x74, 0x6F, 0x72, 0x79,
            0x47, 0x61, 0x6D, 0x65, 0x2F, 0x50, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65,
            0x2F, 0x42, 0x75, 0x69, 0x6C, 0x64, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x42, 0x65, 0x61,
            0x6D, 0x73, 0x2F, 0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x5F, 0x42, 0x65, 0x61, 0x6D,
            0x5F, 0x50, 0x61, 0x69, 0x6E, 0x74, 0x65, 0x64, 0x2E, 0x52, 0x65, 0x63, 0x69, 0x70,
            0x65, 0x5F, 0x42, 0x65, 0x61, 0x6D, 0x5F, 0x50, 0x61, 0x69, 0x6E, 0x74, 0x65, 0x64,
            0x5F, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x00, 0x2F, 0x47, 0x61,
            0x6D, 0x65, 0x2F, 0x46, 0x61, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x47, 0x61, 0x6D, 0x65,
            0x2F, 0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x73, 0x2F, 0x42, 0x75, 0x69, 0x6C, 0x64,
            0x69, 0x6E, 0x67, 0x73, 0x2F, 0x57, 0x61, 0x6C, 0x6C, 0x73, 0x2F, 0x52, 0x65, 0x63,
            0x69, 0x70, 0x65, 0x5F, 0x57, 0x61, 0x6C, 0x6C, 0x5F, 0x38, 0x78, 0x34, 0x5F, 0x30,
            0x31, 0x2E, 0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x5F, 0x57, 0x61, 0x6C, 0x6C, 0x5F,
            0x38, 0x78, 0x34, 0x5F, 0x30, 0x31, 0x5F, 0x43, 0x00,
        ];

        let header = header
            .parse((&DATA[..]).into())
            .expect("Parser should succeed");

        assert_eq!(header.maybe_header_version, 2);
        assert_eq!(header.maybe_save_version, 46);
        assert_eq!(header.maybe_build_version, 368883);
        assert_eq!(header.blueprint_size, [5, 5, 5]);
        assert_eq!(header.resource_list.length, 3);
        assert_eq!(header.recipie_list.count, 2);
    }
}
