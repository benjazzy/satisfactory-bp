mod actor_header;

pub use actor_header::*;

use winnow::{
    Bytes, Parser,
    combinator::{alt, fail, preceded},
    error::StrContext,
};

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ObjectHeaderType<'d> {
    Component,
    Actor(ActorHeader<'d>),
}

pub fn object_header_type<'d>(data: &mut &'d Bytes) -> winnow::Result<ObjectHeaderType<'d>> {
    alt((
        (&0_u32.to_le_bytes()[..]).map(|_| ObjectHeaderType::Component),
        actor_type,
        fail.context(StrContext::Label("unknown header type")),
    ))
    .parse_next(data)
}

fn actor_type<'d>(data: &mut &'d Bytes) -> winnow::Result<ObjectHeaderType<'d>> {
    preceded(
        (&1_u32.to_le_bytes()).context(StrContext::Label("object header type")),
        actor_header.context(StrContext::Label("actor header")),
    )
    .map(ObjectHeaderType::Actor)
    .parse_next(data)
}

#[cfg(test)]
mod tests {
    use super::*;

    // TODO Check component and fail when relevent
    #[test]
    fn check_object_header_type() {
        const DATA: [u8; 0xE6] = [
            0x01, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x2F, 0x47, 0x61, 0x6D, 0x65, 0x2F,
            0x46, 0x61, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x50, 0x72,
            0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x2F, 0x42, 0x75, 0x69, 0x6C, 0x64, 0x61,
            0x62, 0x6C, 0x65, 0x2F, 0x42, 0x65, 0x61, 0x6D, 0x73, 0x2F, 0x42, 0x75, 0x69, 0x6C,
            0x64, 0x5F, 0x42, 0x65, 0x61, 0x6D, 0x5F, 0x50, 0x61, 0x69, 0x6E, 0x74, 0x65, 0x64,
            0x2E, 0x42, 0x75, 0x69, 0x6C, 0x64, 0x5F, 0x42, 0x65, 0x61, 0x6D, 0x5F, 0x50, 0x61,
            0x69, 0x6E, 0x74, 0x65, 0x64, 0x5F, 0x43, 0x00, 0x11, 0x00, 0x00, 0x00, 0x50, 0x65,
            0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6E, 0x74, 0x5F, 0x4C, 0x65, 0x76, 0x65, 0x6C,
            0x00, 0x41, 0x00, 0x00, 0x00, 0x50, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6E,
            0x74, 0x5F, 0x4C, 0x65, 0x76, 0x65, 0x6C, 0x3A, 0x50, 0x65, 0x72, 0x73, 0x69, 0x73,
            0x74, 0x65, 0x6E, 0x74, 0x4C, 0x65, 0x76, 0x65, 0x6C, 0x2E, 0x42, 0x75, 0x69, 0x6C,
            0x64, 0x5F, 0x42, 0x65, 0x61, 0x6D, 0x5F, 0x50, 0x61, 0x69, 0x6E, 0x74, 0x65, 0x64,
            0x5F, 0x43, 0x5F, 0x32, 0x31, 0x34, 0x35, 0x33, 0x39, 0x31, 0x38, 0x31, 0x39, 0x00,
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF3, 0x04,
            0x35, 0xBF, 0xF3, 0x04, 0x35, 0x3F, 0x00, 0x00, 0x48, 0x43, 0x00, 0x00, 0x96, 0xC4,
            0x00, 0x00, 0x48, 0x43, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00,
            0x80, 0x3F, 0x00, 0x00, 0x00, 0x00,
        ];

        let header_type = object_header_type
            .parse(DATA.as_slice().into())
            .expect("Parse should succeed");

        assert!(matches!(header_type, ObjectHeaderType::Actor(_)));
    }
}
