use std::io::Write;

use winnow::{Bytes, Parser, binary::le_u32, combinator::seq, error::StrContext};

use crate::{
    bp_write::BPWrite,
    patterns::body::{
        ObjectRef, PropertyList, object_ref::object_ref, property_list::property_list,
    },
};

#[derive(Debug, Clone, PartialEq)]
pub enum ObjectType<'d> {
    Actor(ActorObject<'d>),
    Component,
}

impl ObjectType<'_> {
    pub fn size(&self) -> u32 {
        match self {
            ObjectType::Actor(actor) => actor.size(),
            ObjectType::Component => unimplemented!(),
        }
    }
}

impl<W: Write> BPWrite<W> for &ObjectType<'_> {
    fn bp_write(self, writer: &mut W) -> Result<(), std::io::Error> {
        match self {
            ObjectType::Actor(actor) => actor.bp_write(writer),
            ObjectType::Component => unimplemented!(),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct ActorObject<'d> {
    parent_object: ObjectRef<'d>,
    // TODO Components
    properties: PropertyList<'d>,
}

impl ActorObject<'_> {
    pub fn size(&self) -> u32 {
        let parent_object_size = self.parent_object.size();
        let properties_size = self.properties.size();

        parent_object_size + properties_size + 12
    }
}

impl<W: Write> BPWrite<W> for &ActorObject<'_> {
    fn bp_write(self, writer: &mut W) -> Result<(), std::io::Error> {
        let parent_size = self.parent_object.size();
        let prop_size = self.properties.size();
        let size = dbg!(parent_size) + dbg!(prop_size) + 8;

        size.bp_write(writer)?;
        self.parent_object.bp_write(writer)?;
        0u32.bp_write(writer)?;
        self.properties.bp_write(writer)?;
        [0u8; 4].bp_write(writer)
    }
}

pub fn actor_object<'d>(data: &mut &'d Bytes) -> winnow::Result<ActorObject<'d>> {
    seq! {ActorObject {
        _: le_u32.context(StrContext::Label("size")),
        parent_object: object_ref,
        _: le_u32.context(StrContext::Label("component count")),
        properties: property_list,
        _: &[0u8; 4],
    }}
    .parse_next(data)
}

#[cfg(test)]
mod tests {
    use crate::patterns::factory_string::FStr;

    use super::*;

    #[test]
    fn check_actor_object() {
        const DATA: [u8; 0x1E8] = [
            0xE4, 0x01, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x50, 0x65, 0x72, 0x73, 0x69, 0x73,
            0x74, 0x65, 0x6E, 0x74, 0x5F, 0x4C, 0x65, 0x76, 0x65, 0x6C, 0x00, 0x34, 0x00, 0x00,
            0x00, 0x50, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6E, 0x74, 0x5F, 0x4C, 0x65,
            0x76, 0x65, 0x6C, 0x3A, 0x50, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6E, 0x74,
            0x4C, 0x65, 0x76, 0x65, 0x6C, 0x2E, 0x42, 0x75, 0x69, 0x6C, 0x64, 0x61, 0x62, 0x6C,
            0x65, 0x53, 0x75, 0x62, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x13, 0x00, 0x00, 0x00, 0x6D, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x69, 0x7A,
            0x61, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x00, 0x0F, 0x00, 0x00, 0x00,
            0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79,
            0x00, 0x9B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x46,
            0x61, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x69, 0x7A,
            0x61, 0x74, 0x69, 0x6F, 0x6E, 0x44, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B,
            0x00, 0x00, 0x00, 0x53, 0x77, 0x61, 0x74, 0x63, 0x68, 0x44, 0x65, 0x73, 0x63, 0x00,
            0x0F, 0x00, 0x00, 0x00, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x50, 0x72, 0x6F, 0x70,
            0x65, 0x72, 0x74, 0x79, 0x00, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x2F, 0x47, 0x61, 0x6D, 0x65, 0x2F,
            0x46, 0x61, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x42, 0x75,
            0x69, 0x6C, 0x64, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x2D, 0x53, 0x68, 0x61, 0x72, 0x65,
            0x64, 0x2F, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x69, 0x7A, 0x61, 0x74, 0x69, 0x6F,
            0x6E, 0x2F, 0x53, 0x77, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x2F, 0x53, 0x77, 0x61,
            0x74, 0x63, 0x68, 0x44, 0x65, 0x73, 0x63, 0x5F, 0x53, 0x6C, 0x6F, 0x74, 0x30, 0x2E,
            0x53, 0x77, 0x61, 0x74, 0x63, 0x68, 0x44, 0x65, 0x73, 0x63, 0x5F, 0x53, 0x6C, 0x6F,
            0x74, 0x30, 0x5F, 0x43, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00,
            0x11, 0x00, 0x00, 0x00, 0x6D, 0x42, 0x75, 0x69, 0x6C, 0x74, 0x57, 0x69, 0x74, 0x68,
            0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x4F, 0x62, 0x6A,
            0x65, 0x63, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x5A, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00,
            0x00, 0x2F, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x46, 0x61, 0x63, 0x74, 0x6F, 0x72, 0x79,
            0x47, 0x61, 0x6D, 0x65, 0x2F, 0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x73, 0x2F, 0x42,
            0x75, 0x69, 0x6C, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x2F, 0x57, 0x61, 0x6C, 0x6C, 0x73,
            0x2F, 0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x5F, 0x57, 0x61, 0x6C, 0x6C, 0x5F, 0x38,
            0x78, 0x34, 0x5F, 0x30, 0x31, 0x2E, 0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x5F, 0x57,
            0x61, 0x6C, 0x6C, 0x5F, 0x38, 0x78, 0x34, 0x5F, 0x30, 0x31, 0x5F, 0x43, 0x00, 0x05,
            0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let actor = actor_object
            .parse(DATA.as_slice().into())
            .expect("parse should succeed");

        assert_eq!(actor.parent_object.level_name, "Persistent_Level\0");
        assert_eq!(
            actor.parent_object.path_name,
            "Persistent_Level:PersistentLevel.BuildableSubsystem\0"
        );

        assert_eq!(actor.properties.0.len(), 2);
        assert_eq!(actor.size() as usize, DATA.len());

        let mut buf = Vec::new();
        actor.bp_write(&mut buf).expect("Write should succeed");

        assert_eq!(buf, DATA);
    }

    #[test]
    fn check_full_actor_object() {
        const DATA: [u8; 0x316] = [
            0x12, 0x03, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x50, 0x65, 0x72, 0x73, 0x69, 0x73,
            0x74, 0x65, 0x6E, 0x74, 0x5F, 0x4C, 0x65, 0x76, 0x65, 0x6C, 0x00, 0x34, 0x00, 0x00,
            0x00, 0x50, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6E, 0x74, 0x5F, 0x4C, 0x65,
            0x76, 0x65, 0x6C, 0x3A, 0x50, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6E, 0x74,
            0x4C, 0x65, 0x76, 0x65, 0x6C, 0x2E, 0x42, 0x75, 0x69, 0x6C, 0x64, 0x61, 0x62, 0x6C,
            0x65, 0x53, 0x75, 0x62, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x08, 0x00, 0x00, 0x00, 0x6D, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x00, 0x0E,
            0x00, 0x00, 0x00, 0x46, 0x6C, 0x6F, 0x61, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72,
            0x74, 0x79, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xC8, 0x42, 0x0B, 0x00, 0x00, 0x00, 0x6D, 0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x53, 0x6C,
            0x6F, 0x74, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x42, 0x79, 0x74, 0x65, 0x50, 0x72, 0x6F,
            0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00, 0x00, 0xFF, 0x13, 0x00, 0x00,
            0x00, 0x6D, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x69, 0x7A, 0x61, 0x74, 0x69, 0x6F,
            0x6E, 0x44, 0x61, 0x74, 0x61, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x53, 0x74, 0x72, 0x75,
            0x63, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x67, 0x01, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x46, 0x61, 0x63, 0x74, 0x6F,
            0x72, 0x79, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x69, 0x7A, 0x61, 0x74, 0x69, 0x6F,
            0x6E, 0x44, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x53,
            0x77, 0x61, 0x74, 0x63, 0x68, 0x44, 0x65, 0x73, 0x63, 0x00, 0x0F, 0x00, 0x00, 0x00,
            0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79,
            0x00, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x61, 0x00, 0x00, 0x00, 0x2F, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x46, 0x61, 0x63, 0x74,
            0x6F, 0x72, 0x79, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x42, 0x75, 0x69, 0x6C, 0x64, 0x61,
            0x62, 0x6C, 0x65, 0x2F, 0x2D, 0x53, 0x68, 0x61, 0x72, 0x65, 0x64, 0x2F, 0x43, 0x75,
            0x73, 0x74, 0x6F, 0x6D, 0x69, 0x7A, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x53, 0x77,
            0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x2F, 0x53, 0x77, 0x61, 0x74, 0x63, 0x68, 0x44,
            0x65, 0x73, 0x63, 0x5F, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x2E, 0x53, 0x77, 0x61,
            0x74, 0x63, 0x68, 0x44, 0x65, 0x73, 0x63, 0x5F, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D,
            0x5F, 0x43, 0x00, 0x12, 0x00, 0x00, 0x00, 0x4F, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64,
            0x65, 0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x44, 0x61, 0x74, 0x61, 0x00, 0x0F, 0x00, 0x00,
            0x00, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74,
            0x79, 0x00, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00,
            0x46, 0x61, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x69,
            0x7A, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x53, 0x6C, 0x6F,
            0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x50, 0x72, 0x69, 0x6D, 0x61,
            0x72, 0x79, 0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x53, 0x74,
            0x72, 0x75, 0x63, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x10,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x4C, 0x69, 0x6E,
            0x65, 0x61, 0x72, 0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x2D,
            0x79, 0x3C, 0x64, 0xEF, 0x0E, 0x3F, 0xEF, 0x90, 0x10, 0x3F, 0x00, 0x00, 0x80, 0x3F,
            0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4E,
            0x6F, 0x6E, 0x65, 0x00, 0x11, 0x00, 0x00, 0x00, 0x6D, 0x42, 0x75, 0x69, 0x6C, 0x74,
            0x57, 0x69, 0x74, 0x68, 0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x00, 0x0F, 0x00, 0x00,
            0x00, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74,
            0x79, 0x00, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x56, 0x00, 0x00, 0x00, 0x2F, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x46, 0x61, 0x63,
            0x74, 0x6F, 0x72, 0x79, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x50, 0x72, 0x6F, 0x74, 0x6F,
            0x74, 0x79, 0x70, 0x65, 0x2F, 0x42, 0x75, 0x69, 0x6C, 0x64, 0x61, 0x62, 0x6C, 0x65,
            0x2F, 0x42, 0x65, 0x61, 0x6D, 0x73, 0x2F, 0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x5F,
            0x42, 0x65, 0x61, 0x6D, 0x5F, 0x50, 0x61, 0x69, 0x6E, 0x74, 0x65, 0x64, 0x2E, 0x52,
            0x65, 0x63, 0x69, 0x70, 0x65, 0x5F, 0x42, 0x65, 0x61, 0x6D, 0x5F, 0x50, 0x61, 0x69,
            0x6E, 0x74, 0x65, 0x64, 0x5F, 0x43, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E,
            0x65, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let actor = actor_object
            .parse(DATA.as_slice().into())
            .expect("parse should succeed");

        assert_eq!(actor.parent_object.level_name, "Persistent_Level\0");
        assert_eq!(
            actor.parent_object.path_name,
            "Persistent_Level:PersistentLevel.BuildableSubsystem\0"
        );

        assert_eq!(actor.properties.0.len(), 4);

        let mut buf = Vec::new();
        actor.bp_write(&mut buf).expect("Write should succeed");

        assert_eq!(buf, DATA);
    }
}
