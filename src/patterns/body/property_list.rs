mod byte_property;
mod float_property;
mod object_property;
mod struct_property;

use std::io::Write;

use winnow::{
    Bytes, Parser,
    combinator::{alt, dispatch, empty, fail, repeat, seq, terminated},
    error::StrContext,
};

pub use byte_property::*;
pub use float_property::*;
pub use object_property::*;
pub use struct_property::*;

use crate::{
    bp_write::BPWrite,
    patterns::factory_string::{FStringExt, fstring},
};

#[derive(Debug, Clone, PartialEq)]
pub enum PropertyType {
    ByteProperty(ByteProperty),
    FloatProperty(FloatProperty),
    ObjectProperty(ObjectProperty),
    StructProperty(StructProperty),
    None,
}

// impl PropertyType<'_> {
//     pub fn size(&self) -> u32 {
//         match self {
//             PropertyType::ByteProperty(byte_property) => byte_property.size(),
//             PropertyType::FloatProperty(_) => 13 + Property::FP.len() as u32,
//             PropertyType::ObjectProperty(object_property) => object_property.size(),
//             PropertyType::StructProperty(struct_property) => struct_property.size(),
//             PropertyType::None => 0,
//         }
//     }
// }

#[derive(Debug, Clone, PartialEq)]
pub struct Property {
    pub name: String,
    pub property: PropertyType,
}

impl Property {
    // const BP: &'static FStr = FStr::new("ByteProperty\0");
    // const FP: &'static FStr = FStr::new("FloatProperty\0");
    // const OP: &'static FStr = FStr::new("ObjectProperty\0");
    // const SP: &'static FStr = FStr::new("StructProperty\0");

    const BP: &'static str = "ByteProperty\0";
    const FP: &'static str = "FloatProperty\0";
    const OP: &'static str = "ObjectProperty\0";
    const SP: &'static str = "StructProperty\0";

    fn get_none_property() -> Property {
        const NAME: &str = "None\0";

        Property {
            name: NAME.to_owned(),
            property: PropertyType::None,
        }
    }

    pub fn size(&self) -> u32 {
        let name_size = self.name.size();
        let type_size = match &self.property {
            PropertyType::ByteProperty(byte_property) => byte_property.size() + Self::BP.size(),
            PropertyType::FloatProperty(_) => 13 + Self::FP.size(),
            PropertyType::ObjectProperty(object_property) => {
                object_property.size() + Self::OP.size()
            }
            PropertyType::StructProperty(struct_property) => {
                struct_property.size() + Self::SP.size()
            }
            PropertyType::None => 0,
        };

        name_size + type_size
    }
}

impl<W: Write> BPWrite<W> for &Property {
    fn bp_write(self, writer: &mut W) -> Result<(), std::io::Error> {
        self.name.bp_write(writer)?;
        match &self.property {
            PropertyType::ByteProperty(byte_property) => {
                Property::BP.bp_write(writer)?;
                byte_property.bp_write(writer)?
            }
            PropertyType::FloatProperty(float_property) => {
                Property::FP.bp_write(writer)?;
                float_property.bp_write(writer)?
            }
            PropertyType::ObjectProperty(object_property) => {
                Property::OP.bp_write(writer)?;
                object_property.bp_write(writer)?
            }
            PropertyType::StructProperty(struct_property) => {
                Property::SP.bp_write(writer)?;
                struct_property.bp_write(writer)?
            }
            PropertyType::None => {}
        }

        Ok(())
    }
}

fn none_property<'d>(data: &mut &'d Bytes) -> winnow::Result<Property> {
    const NP: &str = "None\0";
    seq! { Property {
        name: fstring.verify(|s: &str| s == NP).context(StrContext::Label("name")).map(ToOwned::to_owned),
        property: empty.value(PropertyType::None).context(StrContext::Label("property")),
    }}
    .parse_next(data)
}

fn some_property<'d>(data: &mut &'d Bytes) -> winnow::Result<Property> {
    seq! {Property {
        name: fstring.context(StrContext::Label("property name")).map(ToOwned::to_owned),
        property: dispatch! {fstring.map(|t| t.as_ref()).context(StrContext::Label("property type"));
            Property::BP => byte_property.map(PropertyType::ByteProperty),
            Property::FP => float_property.map(PropertyType::FloatProperty),
            Property::OP => object_property.map(PropertyType::ObjectProperty),
            Property::SP => struct_property.map(PropertyType::StructProperty),
            _ => fail.context(StrContext::Label("unkown property")),
        }
    }}
    .parse_next(data)
}

fn property<'d>(data: &mut &'d Bytes) -> winnow::Result<Property> {
    alt((
        none_property.context(StrContext::Label("none property")),
        some_property.context(StrContext::Label("data containing property")),
    ))
    .parse_next(data)
}

#[derive(Debug, Clone, PartialEq)]
pub struct PropertyList(pub Vec<Property>);

impl PropertyList {
    pub fn size(&self) -> u32 {
        self.0.iter().map(|p| p.size()).sum::<u32>() + Property::get_none_property().size()
    }
}

impl<W: Write> BPWrite<W> for &PropertyList {
    fn bp_write(self, writer: &mut W) -> Result<(), std::io::Error> {
        for prop in &self.0 {
            prop.bp_write(writer)?;
        }

        Property::get_none_property().bp_write(writer)
    }
}

impl<'d> AsRef<[Property]> for PropertyList {
    fn as_ref(&self) -> &[Property] {
        self.0.as_ref()
    }
}

pub fn property_list<'d>(data: &mut &'d Bytes) -> winnow::Result<PropertyList> {
    terminated(
        repeat(
            1..,
            some_property.context(StrContext::Label("data containing property")),
        ),
        none_property.context(StrContext::Label("terminating none property")),
    )
    .context(StrContext::Label("property list"))
    .map(PropertyList)
    .parse_next(data)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn check_property_type_byte() {
        const DATA: [u8; 0x33] = [
            0x0B, 0x00, 0x00, 0x00, 0x6D, 0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x53, 0x6C, 0x6F, 0x74,
            0x00, 0x0D, 0x00, 0x00, 0x00, 0x42, 0x79, 0x74, 0x65, 0x50, 0x72, 0x6F, 0x70, 0x65,
            0x72, 0x74, 0x79, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
            0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00, 0x00, 0xFF,
        ];

        let prop = property
            .parse(DATA.as_slice().into())
            .expect("Parse should succeed");

        assert_eq!(prop.name, "mColorSlot\0");
        assert!(matches!(prop.property, PropertyType::ByteProperty(_)));

        let mut buf = Vec::new();
        prop.bp_write(&mut buf).expect("Write should succed");

        assert_eq!(buf, DATA);
    }

    #[test]
    fn check_property_type_none() {
        const DATA: [u8; 0x09] = [0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00];

        let prop = property
            .parse(DATA.as_slice().into())
            .expect("Parse should succeed");

        assert_eq!(prop.name, "None\0");
        assert_eq!(prop.property, PropertyType::None);
        assert_eq!(prop.size() as usize, DATA.len());

        let mut buf = Vec::new();
        prop.bp_write(&mut buf).expect("Write should succed");

        assert_eq!(buf, DATA);
    }

    #[test]
    fn check_property_list() {
        const DATA: [u8; 0x9B] = [
            0x0B, 0x00, 0x00, 0x00, 0x53, 0x77, 0x61, 0x74, 0x63, 0x68, 0x44, 0x65, 0x73, 0x63,
            0x00, 0x0F, 0x00, 0x00, 0x00, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x50, 0x72, 0x6F,
            0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x2F, 0x47, 0x61, 0x6D, 0x65,
            0x2F, 0x46, 0x61, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x42,
            0x75, 0x69, 0x6C, 0x64, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x2D, 0x53, 0x68, 0x61, 0x72,
            0x65, 0x64, 0x2F, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x69, 0x7A, 0x61, 0x74, 0x69,
            0x6F, 0x6E, 0x2F, 0x53, 0x77, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x2F, 0x53, 0x77,
            0x61, 0x74, 0x63, 0x68, 0x44, 0x65, 0x73, 0x63, 0x5F, 0x53, 0x6C, 0x6F, 0x74, 0x30,
            0x2E, 0x53, 0x77, 0x61, 0x74, 0x63, 0x68, 0x44, 0x65, 0x73, 0x63, 0x5F, 0x53, 0x6C,
            0x6F, 0x74, 0x30, 0x5F, 0x43, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65,
            0x00,
        ];

        let prop_list = property_list
            .parse(DATA.as_slice().into())
            .expect("Parse should succeed");

        assert_eq!(prop_list.0.len(), 1);
        assert_eq!(prop_list.0[0].name, "SwatchDesc\0");
        assert!(matches!(
            prop_list.0[0].property,
            PropertyType::ObjectProperty(_)
        ));
        assert_eq!(prop_list.size() as usize, DATA.len());

        let mut buf = Vec::new();
        prop_list.bp_write(&mut buf).expect("Write should succed");

        assert_eq!(buf, DATA);
    }

    #[test]
    fn check_property_list_size() {
        const DATA: [u8; 0x2BD] = [
            0x08, 0x00, 0x00, 0x00, 0x6D, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x00, 0x0E, 0x00,
            0x00, 0x00, 0x46, 0x6C, 0x6F, 0x61, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74,
            0x79, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC8,
            0x42, 0x0B, 0x00, 0x00, 0x00, 0x6D, 0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x53, 0x6C, 0x6F,
            0x74, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x42, 0x79, 0x74, 0x65, 0x50, 0x72, 0x6F, 0x70,
            0x65, 0x72, 0x74, 0x79, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
            0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00, 0x00, 0xFF, 0x13, 0x00, 0x00, 0x00,
            0x6D, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x69, 0x7A, 0x61, 0x74, 0x69, 0x6F, 0x6E,
            0x44, 0x61, 0x74, 0x61, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x53, 0x74, 0x72, 0x75, 0x63,
            0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x67, 0x01, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x46, 0x61, 0x63, 0x74, 0x6F, 0x72,
            0x79, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x69, 0x7A, 0x61, 0x74, 0x69, 0x6F, 0x6E,
            0x44, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x53, 0x77,
            0x61, 0x74, 0x63, 0x68, 0x44, 0x65, 0x73, 0x63, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x4F,
            0x62, 0x6A, 0x65, 0x63, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00,
            0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61,
            0x00, 0x00, 0x00, 0x2F, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x46, 0x61, 0x63, 0x74, 0x6F,
            0x72, 0x79, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x42, 0x75, 0x69, 0x6C, 0x64, 0x61, 0x62,
            0x6C, 0x65, 0x2F, 0x2D, 0x53, 0x68, 0x61, 0x72, 0x65, 0x64, 0x2F, 0x43, 0x75, 0x73,
            0x74, 0x6F, 0x6D, 0x69, 0x7A, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x53, 0x77, 0x61,
            0x74, 0x63, 0x68, 0x65, 0x73, 0x2F, 0x53, 0x77, 0x61, 0x74, 0x63, 0x68, 0x44, 0x65,
            0x73, 0x63, 0x5F, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x2E, 0x53, 0x77, 0x61, 0x74,
            0x63, 0x68, 0x44, 0x65, 0x73, 0x63, 0x5F, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x5F,
            0x43, 0x00, 0x12, 0x00, 0x00, 0x00, 0x4F, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65,
            0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x44, 0x61, 0x74, 0x61, 0x00, 0x0F, 0x00, 0x00, 0x00,
            0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79,
            0x00, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x46,
            0x61, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x69, 0x7A,
            0x61, 0x74, 0x69, 0x6F, 0x6E, 0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x53, 0x6C, 0x6F, 0x74,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x50, 0x72, 0x69, 0x6D, 0x61, 0x72,
            0x79, 0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x53, 0x74, 0x72,
            0x75, 0x63, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x10, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x4C, 0x69, 0x6E, 0x65,
            0x61, 0x72, 0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x2D, 0x79,
            0x3C, 0x64, 0xEF, 0x0E, 0x3F, 0xEF, 0x90, 0x10, 0x3F, 0x00, 0x00, 0x80, 0x3F, 0x05,
            0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F,
            0x6E, 0x65, 0x00, 0x11, 0x00, 0x00, 0x00, 0x6D, 0x42, 0x75, 0x69, 0x6C, 0x74, 0x57,
            0x69, 0x74, 0x68, 0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x00, 0x0F, 0x00, 0x00, 0x00,
            0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79,
            0x00, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x56, 0x00, 0x00, 0x00, 0x2F, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x46, 0x61, 0x63, 0x74,
            0x6F, 0x72, 0x79, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x50, 0x72, 0x6F, 0x74, 0x6F, 0x74,
            0x79, 0x70, 0x65, 0x2F, 0x42, 0x75, 0x69, 0x6C, 0x64, 0x61, 0x62, 0x6C, 0x65, 0x2F,
            0x42, 0x65, 0x61, 0x6D, 0x73, 0x2F, 0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x5F, 0x42,
            0x65, 0x61, 0x6D, 0x5F, 0x50, 0x61, 0x69, 0x6E, 0x74, 0x65, 0x64, 0x2E, 0x52, 0x65,
            0x63, 0x69, 0x70, 0x65, 0x5F, 0x42, 0x65, 0x61, 0x6D, 0x5F, 0x50, 0x61, 0x69, 0x6E,
            0x74, 0x65, 0x64, 0x5F, 0x43, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65,
            0x00,
        ];

        let prop_list = property_list
            .parse(DATA.as_slice().into())
            .expect("Parse should succeed");

        assert_eq!(prop_list.0.len(), 4);
        assert_eq!(prop_list.0[0].size(), 43);
        assert_eq!(prop_list.0[1].size(), 51);
        assert_eq!(prop_list.0[2].size(), 455);
        assert_eq!(prop_list.0[3].size(), 143);
        assert_eq!(prop_list.size() as usize, DATA.len());
    }
}
