use std::io::Write;

use winnow::{
    Bytes, Parser,
    binary::le_u32,
    combinator::{preceded, repeat},
    error::StrContext,
};

use crate::{
    bp_write::BPWrite,
    patterns::factory_string::{FStr, fstring},
};

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Recipe<'d>(pub &'d FStr);

impl<W: Write> BPWrite<W> for &Recipe<'_> {
    fn bp_write(self, writer: &mut W) -> Result<(), std::io::Error> {
        [0u8; 4].bp_write(writer)?;
        self.0.bp_write(writer)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Default)]
pub struct RecipeList<'d> {
    pub recipies: Vec<Recipe<'d>>,
}

impl<W: Write> BPWrite<W> for &RecipeList<'_> {
    fn bp_write(self, writer: &mut W) -> Result<(), std::io::Error> {
        let count: u32 = self
            .recipies
            .len()
            .try_into()
            .expect("Recipies length is too long");
        count.bp_write(writer)?;

        self.recipies.bp_write(writer)
    }
}

pub fn recipe_list<'d>(data: &mut &'d Bytes) -> winnow::Result<RecipeList<'d>> {
    let count = le_u32
        .context(StrContext::Label("recipie list length"))
        .parse_next(data)?;
    let recipies = repeat(count as usize, preceded(&[0x00; 4], fstring.map(Recipe)))
        .context(StrContext::Label("recipe path"))
        .parse_next(data)?;

    Ok(RecipeList { recipies })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn check_recipe_list() {
        const DATA: [u8; 0xBC] = [
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00, 0x00, 0x2F, 0x47,
            0x61, 0x6D, 0x65, 0x2F, 0x46, 0x61, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x47, 0x61, 0x6D,
            0x65, 0x2F, 0x50, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x2F, 0x42, 0x75,
            0x69, 0x6C, 0x64, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x42, 0x65, 0x61, 0x6D, 0x73, 0x2F,
            0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x5F, 0x42, 0x65, 0x61, 0x6D, 0x5F, 0x50, 0x61,
            0x69, 0x6E, 0x74, 0x65, 0x64, 0x2E, 0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x5F, 0x42,
            0x65, 0x61, 0x6D, 0x5F, 0x50, 0x61, 0x69, 0x6E, 0x74, 0x65, 0x64, 0x5F, 0x43, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x00, 0x2F, 0x47, 0x61, 0x6D, 0x65, 0x2F,
            0x46, 0x61, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x52, 0x65,
            0x63, 0x69, 0x70, 0x65, 0x73, 0x2F, 0x42, 0x75, 0x69, 0x6C, 0x64, 0x69, 0x6E, 0x67,
            0x73, 0x2F, 0x57, 0x61, 0x6C, 0x6C, 0x73, 0x2F, 0x52, 0x65, 0x63, 0x69, 0x70, 0x65,
            0x5F, 0x57, 0x61, 0x6C, 0x6C, 0x5F, 0x38, 0x78, 0x34, 0x5F, 0x30, 0x31, 0x2E, 0x52,
            0x65, 0x63, 0x69, 0x70, 0x65, 0x5F, 0x57, 0x61, 0x6C, 0x6C, 0x5F, 0x38, 0x78, 0x34,
            0x5F, 0x30, 0x31, 0x5F, 0x43, 0x00,
        ];

        let first = Recipe("/Game/FactoryGame/Prototype/Buildable/Beams/Recipe_Beam_Painted.Recipe_Beam_Painted_C\0".into());
        let second = Recipe(
            "/Game/FactoryGame/Recipes/Buildings/Walls/Recipe_Wall_8x4_01.Recipe_Wall_8x4_01_C\0"
                .into(),
        );

        let recipies = recipe_list
            .parse((&DATA[..]).into())
            .expect("Parser should succeed");

        assert_eq!(recipies.recipies, &[first, second]);

        let mut buf = Vec::new();
        recipies.bp_write(&mut buf).expect("Write should succeed");

        assert_eq!(buf, DATA);
    }
}
