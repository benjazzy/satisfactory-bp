use std::io::Write;

use winnow::{Bytes, Parser, binary::le_u32, combinator::preceded};

use crate::{
    bp_write::BPWrite,
    patterns::factory_string::{FString, fstring},
};

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ResourceList<'d> {
    pub resources: Vec<Resource<'d>>,
}

impl<W: Write> BPWrite<W> for &ResourceList<'_> {
    fn bp_write(self, writer: &mut W) -> Result<(), std::io::Error> {
        let length: u32 = self.resources.len().try_into().expect("Too many resources");
        length.bp_write(writer)?;

        self.resources.bp_write(writer)
    }
}

pub fn resource_list<'d>(data: &mut &'d Bytes) -> winnow::Result<ResourceList<'d>> {
    let length = le_u32.parse_next(data)?;
    let resources = (0..length)
        .flat_map(|_| resource.parse_next(data))
        .collect::<Vec<_>>();

    Ok(ResourceList { resources })
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Resource<'d> {
    pub path: FString<'d>,
    pub count: u32,
}

impl<W: Write> BPWrite<W> for &Resource<'_> {
    fn bp_write(self, writer: &mut W) -> Result<(), std::io::Error> {
        [0x00; 4].bp_write(writer)?;
        self.path.bp_write(writer)?;

        writer.write_all(self.count.to_le_bytes().as_slice())
    }
}

pub fn resource<'d>(data: &mut &'d Bytes) -> winnow::Result<Resource<'d>> {
    let (path, count) = preceded(&[0x00; 4], (fstring, le_u32)).parse_next(data)?;

    Ok(Resource { path, count })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn check_resource() {
        const DATA: [u8; 0x5A] = [
            0x00, 0x00, 0x00, 0x00, 0x4E, 0x00, 0x00, 0x00, 0x2F, 0x47, 0x61, 0x6D, 0x65, 0x2F,
            0x46, 0x61, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x52, 0x65,
            0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x2F, 0x50, 0x61, 0x72, 0x74, 0x73, 0x2F, 0x53,
            0x74, 0x65, 0x65, 0x6C, 0x50, 0x6C, 0x61, 0x74, 0x65, 0x2F, 0x44, 0x65, 0x73, 0x63,
            0x5F, 0x53, 0x74, 0x65, 0x65, 0x6C, 0x50, 0x6C, 0x61, 0x74, 0x65, 0x2E, 0x44, 0x65,
            0x73, 0x63, 0x5F, 0x53, 0x74, 0x65, 0x65, 0x6C, 0x50, 0x6C, 0x61, 0x74, 0x65, 0x5F,
            0x43, 0x00, 0x02, 0x00, 0x00, 0x00,
        ];

        let resource = resource
            .parse((&DATA[..]).into())
            .expect("Parser should succeed");

        assert_eq!(
            resource.path,
            "/Game/FactoryGame/Resource/Parts/SteelPlate/Desc_SteelPlate.Desc_SteelPlate_C\0"
                .into()
        );
        assert_eq!(resource.count, 2);

        let mut buf = Vec::new();
        resource.bp_write(&mut buf).expect("Write should succeed");

        assert_eq!(buf, DATA);
    }

    #[test]
    fn check_resource_list() {
        const DATA: [u8; 0x103] = [
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E, 0x00, 0x00, 0x00, 0x2F, 0x47,
            0x61, 0x6D, 0x65, 0x2F, 0x46, 0x61, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x47, 0x61, 0x6D,
            0x65, 0x2F, 0x52, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x2F, 0x50, 0x61, 0x72,
            0x74, 0x73, 0x2F, 0x53, 0x74, 0x65, 0x65, 0x6C, 0x50, 0x6C, 0x61, 0x74, 0x65, 0x2F,
            0x44, 0x65, 0x73, 0x63, 0x5F, 0x53, 0x74, 0x65, 0x65, 0x6C, 0x50, 0x6C, 0x61, 0x74,
            0x65, 0x2E, 0x44, 0x65, 0x73, 0x63, 0x5F, 0x53, 0x74, 0x65, 0x65, 0x6C, 0x50, 0x6C,
            0x61, 0x74, 0x65, 0x5F, 0x43, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x4B, 0x00, 0x00, 0x00, 0x2F, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x46, 0x61, 0x63, 0x74,
            0x6F, 0x72, 0x79, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x52, 0x65, 0x73, 0x6F, 0x75, 0x72,
            0x63, 0x65, 0x2F, 0x50, 0x61, 0x72, 0x74, 0x73, 0x2F, 0x49, 0x72, 0x6F, 0x6E, 0x50,
            0x6C, 0x61, 0x74, 0x65, 0x2F, 0x44, 0x65, 0x73, 0x63, 0x5F, 0x49, 0x72, 0x6F, 0x6E,
            0x50, 0x6C, 0x61, 0x74, 0x65, 0x2E, 0x44, 0x65, 0x73, 0x63, 0x5F, 0x49, 0x72, 0x6F,
            0x6E, 0x50, 0x6C, 0x61, 0x74, 0x65, 0x5F, 0x43, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 0x2F, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x46,
            0x61, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x47, 0x61, 0x6D, 0x65, 0x2F, 0x52, 0x65, 0x73,
            0x6F, 0x75, 0x72, 0x63, 0x65, 0x2F, 0x50, 0x61, 0x72, 0x74, 0x73, 0x2F, 0x43, 0x65,
            0x6D, 0x65, 0x6E, 0x74, 0x2F, 0x44, 0x65, 0x73, 0x63, 0x5F, 0x43, 0x65, 0x6D, 0x65,
            0x6E, 0x74, 0x2E, 0x44, 0x65, 0x73, 0x63, 0x5F, 0x43, 0x65, 0x6D, 0x65, 0x6E, 0x74,
            0x5F, 0x43, 0x00, 0x02, 0x00, 0x00, 0x00,
        ];

        let list = ResourceList {
            resources: vec![
                Resource { path: "/Game/FactoryGame/Resource/Parts/SteelPlate/Desc_SteelPlate.Desc_SteelPlate_C\0".into(), count: 2 },
                Resource { path: "/Game/FactoryGame/Resource/Parts/IronPlate/Desc_IronPlate.Desc_IronPlate_C\0".into(), count: 2 },
                Resource { path: "/Game/FactoryGame/Resource/Parts/Cement/Desc_Cement.Desc_Cement_C\0".into(), count: 2 },
            ],
        };

        let resources = resource_list
            .parse((&DATA[..]).into())
            .expect("Parser should succeed");

        assert_eq!(resources, list);

        let mut buf = Vec::new();
        resources.bp_write(&mut buf).expect("Write should succeed");

        assert_eq!(buf, DATA);
    }
}
